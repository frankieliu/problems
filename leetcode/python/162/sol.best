
Find the maximum by binary search (recursion and iteration)

https://leetcode.com/problems/find-peak-element/discuss/50232

* Lang:    cpp
* Author:  gangan
* Votes:   276

Consider that each local maximum is one valid peak.
My solution is to find one local maximum with binary search.
Binary search satisfies the O(logn) computational complexity.

Binary Search: recursion

    class Solution {
    public:

    int findPeakElement(const vector<int> &num) {
        return Helper(num, 0, num.size()-1);
    }
    int Helper(const vector<int> &num, int low, int high)
    {
        if(low == high)
            return low;
        else
        {
            int mid1 = (low+high)/2;
            int mid2 = mid1+1;
            if(num[mid1] > num[mid2])
                return Helper(num, low, mid1);
            else
                return Helper(num, mid2, high);
        }
    }
    };

Binary Search: iteration

    class Solution {
    public:
        int findPeakElement(const vector<int> &num) 
        {
            int low = 0;
            int high = num.size()-1;
            
            while(low < high)
            {
                int mid1 = (low+high)/2;
                int mid2 = mid1+1;
                if(num[mid1] < num[mid2])
                    low = mid2;
                else
                    high = mid1;
            }
            return low;
        }
    };

Sequential Search:

    class Solution {
    public:
        int findPeakElement(const vector<int> &num) {
            for(int i = 1; i < num.size(); i ++)
            {
                if(num[i] < num[i-1])
                {// <
                    return i-1;
                }
            }
            return num.size()-1;
        }
    };
